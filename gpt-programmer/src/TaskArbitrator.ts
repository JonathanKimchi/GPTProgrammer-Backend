/**
 * this class is responsible for managing the tasks
 * and assigning them to the workers (also called generators)
 * 
 * This class is also responsible for taking in the commands 
 * generated by the generators and executing them using the
 * plugins attached to the generators.
 * 
 */

import { Command } from "./models/commands/Command";
import { CommandHandler } from "./handlers/commands/CommandHandler";
import { OutputHandler } from "./handlers/outputs/OutputHandler";
import { LLMProxy } from "./llmapi/LLMProxy";
import { LLMProxyFactory } from "./llmapi/LLMProxyFactory";
import { LLM_LABEL, LLM_MODEL } from "./environment/EnvConfig";
import { CommandGenerator } from "./generators/CommandGenerator";
import { CommandGeneratorFactory } from "./generators/CommandGeneratorFactory";
import { Task } from "./models/tasks/Task";

export class TaskArbitrator {

    protected llmLabel: string;
    protected llmModel: string;
    protected llmProxy: LLMProxy;
    protected taskList: Task[];
    protected commandGeneratorMap: Map<string, CommandGenerator>;
    protected commandList: Command[];
    protected commandHandler: CommandHandler;
    protected outputHandler: OutputHandler;
    protected taskArbitrationPrePrompt: string;

    // constructor
    constructor(llmLabel: string = LLM_LABEL, llmModel: string = LLM_MODEL) {
        this.llmLabel = llmLabel;
        this.llmModel = llmModel;
        this.llmProxy = LLMProxyFactory.getLLMProxy(llmLabel);
        this.taskList = [];
        this.commandGeneratorMap = CommandGeneratorFactory.getCommandGeneratorMap();
        this.commandList = [];
        this.commandHandler = new CommandHandler([], []);
        this.outputHandler = new OutputHandler();
        this.taskArbitrationPrePrompt = 
        `
        You are a product manager at a software company.
        You are tasked with creating a list of tasks for your team to complete based on a product requirements document.
        The product requirements document is a document that describes the features of a product.
        The tasks are the steps that your team will take to implement the features described in the product requirements document.

        Always respond in Json format. For example, if you want to respond with a list of tasks, you would respond with:
        [
            {
                "teamMember": "FrontendGenerator",
                "task": "<task description with full context>"
            },
            {
                "teamMember": "BackendGenerator",
                "task": "<task description with full context>"
            }
            ...
        ]

        Here are the members of your team:
        {generatorDescriptions}

        Here are the product requirements:
        {productRequirements}

        now, please respond with a list of tasks for your team to complete based on the product requirements.

        Task list in Json format:
        
        `
    }

    /**
     * a function that takes in a prompt which is a product requirements document
     * and generates a list of tasks, with each task directed to a specific generator.
     * The function gets a list of commands from any generator that has a task assigned to it
     * and executes the commands using the plugins attached to the generators.
     */
    public async handleTaskArbitration(promptWithProductRequirements: string) {
        // first, use the llm api to generate a list of tasks
        let taskList: Task[] = await this.generateTaskListFromLLM(promptWithProductRequirements);
        // then, using the teamMember field of each task, get a list of commands from the generators
        for (let task of taskList) {
            let generator: CommandGenerator = this.commandGeneratorMap.get(task.teamMember);
            let commandList: Command[] = await generator.generateCommandList(task.task);
            this.commandList.concat(commandList);
            // then, execute the commands using the plugins attached to the generators
            for (let command of commandList) {
                for (let plugin of generator.getAcceptedPlugins()) {
                    if (plugin.canHandleCommand(command)) {
                        plugin.handleCommand(command);
                        break;
                    }
                }
            }
        }
    }

        

    public async generateTaskListFromLLM(promptWithProductRequirements: string): Promise<Task[]> {
        // first, use the llm api to generate raw AI output from the prompt
        let rawOutput: string = await this.generateAiOutput(promptWithProductRequirements);
        // then, use the raw AI output to generate a list of tasks
        let taskList: Task[] = this.getTaskListFromRawOutput(rawOutput);
        // then, return the task list
        return taskList;
    }

    getTaskListFromRawOutput(input: string): Task[] {
        const tasks = [];
      
        // Define a regular expression to match the JSON string within the input
        const jsonRegex = /\[\s*{\s*"teamMember"\s*:\s*".*?",\s*"task"\s*:\s*".*?"\s*}\s*(,\s*{\s*"teamMember"\s*:\s*".*?",\s*"task"\s*:\s*".*?"\s*}\s*)*\]/;
        const jsonMatch = input.match(jsonRegex);
      
        if (jsonMatch) {
          const jsonStr = jsonMatch[0];
          const parsed = JSON.parse(jsonStr);
      
          // Iterate over the tasks and add them to the list
          for (const task of parsed) {
            tasks.push(task);
          }
        } else {
          console.error("Error parsing input: no JSON data found");
        }
      
        return tasks;
      }
      

    // function that generates raw AI output from the prompt
    public async generateAiOutput(promptWithProductRequirements: string): Promise<string> {
        let prePrompt = this.taskArbitrationPrePrompt;
        let generatorDescriptions = this.getGeneratorDescriptions();
        let productRequirements = promptWithProductRequirements;
        let prompt = prePrompt
            .replace("{generatorDescriptions}", generatorDescriptions)
            .replace("{productRequirements}", productRequirements);
        let rawOutput: string = await this.llmProxy.generateChatCompletion(prompt);
        return rawOutput;
    }

    // function that returns a string containing the descriptions of the generators
    public getGeneratorDescriptions(): string {
        let generatorDescriptions: string = "";
        for (let generator of this.commandGeneratorMap.values()) {
            generatorDescriptions += generator.getCommandGeneratorDescription() + "\n";
        }
        return generatorDescriptions;
    }

    // function that adds a task to the task list
    public addTask(task: Task): void {
        this.taskList.push(task);
    }

    // function that removes a task from the task list
    public removeTask(task: Task): void {
        let index = this.taskList.indexOf(task);
        if (index > -1) {
            this.taskList.splice(index, 1);
        }
    }

    // function that returns the task list
    public getTaskList(): Task[] {
        return this.taskList;
    }
}